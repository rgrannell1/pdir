
"use strict"




const path           = require('path')
const events         = require('events')
const mkdirp         = require('mkdirp')
const utils          = require('pdir/commons/utils')
const constants      = require('pdir/commons/constants')
const partitionFiles = require('pdir/app/partition-files')





const targetPath = (sourcePath, grouping) => {

	const targetDir = `${path.dirname(sourcePath)}-${grouping}`
	return path.join(targetDir, path.basename(sourcePath))

}





const pdir = rawArgs => {

	const args        = pdir.validate(pdir.preprocess(rawArgs))
	const partitioned = new events.EventEmitter( )

	if (path.dirname(constants.canonicalDir) === constants.canonicalDir) {

		process.stderr.write('error: will not operate on root directory.\n')
		process.exit(1)

	}

	partitioned.on(constants.events.partitioned, event => {

		const targetFilePath = targetPath(event.fpath, event.grouping)

		if (args.dryRun) {

			console.log(`${event.fpath}    ${targetFilePath}`)

		} else {

			mkdirp(path.dirname(targetFilePath), err => {
				utils.fs.moveFile(event.fpath, targetFilePath, err => {

					if (err) {
						process.stderr.write('error: failed to move file: ${err.message}')
					}

				})
			})

		}

	})

	args.dirs.forEach(dir => {
		utils.fs.listContent(dir, content => {

			utils.fs.emitFileTypes(content)
				.on(constants.events.file, filePath => {
					partitionFiles(partitioned, args, filePath)
				})

		})
	})

}





pdir.preprocess = rawArgs => {

	return {
		dryRun:     rawArgs['--dry-run'],
		dirs:       pdir.preprocess.dirs(rawArgs.SRC),
		extensions: pdir.preprocess.extensions(rawArgs['--extensions'])
	}

}

pdir.preprocess.dirs = dirs => {

	return dirs.map(dir => {
		return path.resolve(process.cwd( ), dir)
	})

}

pdir.preprocess.extensions = extensionGroups => {

	return extensionGroups.map(extensionGroup => {

		const extensions = extensionGroup
			.split(constants.regexs.extensionDelimiter)
			.map(extension => {
				return extension.replace(/^[.]/, '')
			})

		return utils.hof.uniqueOf(extensions)

	})

}





pdir.validate = args => {

	pdir.validate.extensions(args.extensions)

	return args

}

pdir.validate.extensions = extensions => {

	const usedExtensions = Array.prototype.concat.apply([ ], extensions)

	if (utils.hof.uniqueOf(usedExtensions).length !== usedExtensions.length) {

		const summarised = extensions.join('|')

		process.stderr.write(
			'error: extensions were shared between extensions groups:\n' +
			summarised + '\n'
		)
		process.exit(1)

	}

}





module.exports = pdir
