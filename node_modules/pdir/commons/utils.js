
"use strict"




const fs           = require('fs')
const path         = require('path')
const events       = require('events')
const crypto       = require('crypto')
const readline     = require('readline')
const constants    = require('pdir/commons/constants')




const utils = {
	fs:     { },
	hof:    { },
	crypto: { },
	array:  { }
}





utils.fs.handleFileError = (err, file) => {

	const handledErrors = {
		[constants.errCodes.notFound]: `file ${file} does not exist.`
	}

	process.stderr.write(
		handledErrors.hasOwnProperty(err.code)
			? 'error: ' + handledErrors[err.code] + '\n'
			: 'error: ' + err.message + '\n')

}





utils.fs.listContent = (dir, callback) => {

	fs.lstat(dir, (err, stats) => {

		if (err) {

			utils.fs.handleFileError(err, dir)
			return callback([ ])

		}

		if (!stats.isDirectory( )) {
			process.stderr.write(`error: ${dir} was not a directory.`)
		} else {

			fs.access(dir, fs.R_OK, err => {

				if (err) {

					utils.fs.handleFileError(err, dir)
					return callback([ ])

				}

				fs.readdir(dir, (err, contents) => {
					callback( contents.map(content => {
						return path.resolve(constants.workingDir, dir, content)
					}) )
				})

			})
		}

	})

}

utils.fs.emitFileTypes = contents => {

	const emitter = new events.EventEmitter( )

	contents.forEach(content => {
		fs.lstat(content, (err, stats) => {

			if (err) {
				return utils.fs.handleFileError(err, content)
			}

			constants.statTypeMethods.forEach(methodName => {

				if (stats[methodName]( )) {
					emitter.emit(methodName.replace(/^is/, '').toLowerCase( ), content)
				}

			})

		})
	})

	return emitter

}

utils.fs.extension = fpath => {

	const basename = path.basename(fpath)
	const dotIndex = basename.indexOf('.')

	return dotIndex === -1
		? ''
		: basename.slice(dotIndex).replace(/^[.]/, '')

}

utils.fs.copyFile = (srcPath, tgtPath, copy, callback) => {

	const singleCallback = utils.hof.once(callback)

	const streamEmitter = new events.EventEmitter( )
	const streams       = {
		read:  {src: fs.createReadStream(srcPath)},
		write: {tgt: fs.createWriteStream(tgtPath)}
	}

	const hashes = {
		src: crypto.createHash(constants.hashes.sha256).setEncoding('hex'),
		tgt: crypto.createHash(constants.hashes.sha256).setEncoding('hex')
	}

	/*
		when the file is fully copied, read and get the checksum.
	*/

	streams.write.tgt.on(constants.events.finish, ( ) => {

		streams.read.tgt  =
			fs.createReadStream(tgtPath)
				.on(constants.events.error, err => {
					streamEmitter.emit(constants.events.error, err)
				})

		streams.read.tgt.pipe(hashes.tgt)

		streams.read.tgt.on(constants.events.end, ( ) => {

			hashes.tgt.end( )
			streamEmitter.emit('targetChecksum', hashes.tgt.read( ))

		})

	})

	streams.read.src
		.on(constants.events.error, err => {
			streamEmitter.emit(constants.events.error, err)
		})
		.on(constants.events.end, ( ) => {

			hashes.src.end( )
			streamEmitter.emit('sourceChecksum', hashes.src.read( ))

		})

	streams.read.src.pipe(hashes.src)
	streams.read.src.pipe(streams.write.tgt)

	/*
		after each file is hashed,
		compare them. If they match, remove the original file if possible.
	*/

	streamEmitter
		.on('error', err => {
			singleCallback(err)
		})
		.on('sourceChecksum', srcHash => {
			streamEmitter.on('targetChecksum', tgtHash => {

				if (tgtHash !== srcHash) {
					process.stderr.write('error: checksum mismatch between ${srcPath} and ${tgtHash}; reverting.\n')
					return

				} else if (!copy) {

					fs.unlink(srcPath, err => {

						if (err) {
							process.stderr.write('error: error while attempting to remove ${srcPath}: ${err.message}\n')
						}

					})

				}

			})
		})

}





utils.fs.readStdin = callback => {

	const lines = [ ]

	readline.createInterface({
		input: process.stdin
	})
	.on('line', line => {
		lines.push(line)
	})
	.on('close', ( ) => {
		callback(lines)
	})

}





utils.array.isIn = (val, array) => {
	return array.indexOf(val) !== -1
}





utils.hof.uniqueOf = elements => {

	var unique = [ ]

	elements.forEach(element => {

		if (!utils.array.isIn(element, unique)) {
			unique.push(element)
		}

	})

	return unique

}

utils.hof.once = function (fn) {

	var wasCalled = false

	return function ( ) {
		if (!wasCalled) {
			fn.apply([ ], arguments)
			wasCalled = true
		}
	}

}









module.exports = utils
