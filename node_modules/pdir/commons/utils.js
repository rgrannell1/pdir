
"use strict"




const fs           = require('fs')
const path         = require('path')
const events       = require('events')
const crypto       = require('crypto')
const readline     = require('readline')
const childProcess = require('child_process')
const constants    = require('pdir/commons/constants')




const utils = {
	fs:     { },
	hof:    { },
	crypto: { },
	array:  { }
}





const handleFileError = (err, file) => {

	const handledErrors = {
		[constants.errCodes.notFound]: `file ${file} does not exist.`
	}

	process.stderr.write(
		handledErrors.hasOwnProperty(err.code)
			? 'error: ' + handledErrors[err.code] + '\n'
			: 'error: ' + err.message + '\n')

}





utils.fs.listContent = (dir, callback) => {

	fs.lstat(dir, (err, stats) => {

		if (err) {

			handleFileError(err, dir)
			return callback([ ])

		}

		if (!stats.isDirectory( )) {
			process.stderr.write(`error: ${dir} was not a directory.`)
		} else {

			fs.access(dir, fs.R_OK, err => {

				if (err) {

					handleFileError(err, dir)
					return callback([ ])

				}

				fs.readdir(dir, (err, contents) => {
					callback( contents.map(content => {
						return path.resolve(constants.canonicalDir, dir, content)
					}) )
				})

			})
		}

	})

}

utils.fs.emitFileTypes = contents => {

	const emitter = new events.EventEmitter( )

	contents.forEach(content => {
		fs.lstat(content, (err, stats) => {

			if (err) {
				return handleFileError(err, content)
			}

			constants.statTypeMethods.forEach(methodName => {

				if (stats[methodName]( )) {
					emitter.emit(methodName.replace(/^is/, '').toLowerCase( ), content)
				}

			})

		})
	})

	return emitter

}

utils.fs.extension = fpath => {

	const basename = path.basename(fpath)
	const dotIndex = basename.indexOf('.')

	return dotIndex === -1
		? ''
		: basename.slice(dotIndex).replace(/^[.]/, '')

}

utils.fs.moveFile = (srcPath, tgtPath, callback) => {

	if (process.platform === 'win32') {
		throw Error('windows is currently unsupported.')
	} else {

		childProcess.exec(`mv "${srcPath}" "${tgtPath}"`, (err, stdout, stderr) => {
			callback(err)
		})

	}

}

utils.fs.readStdin = callback => {

	const lines = [ ]

	readline.createInterface({
		input: process.stdin
	})
	.on('line', line => {
		lines.push(line)
	})
	.on('close', ( ) => {
		callback(lines)
	})

}





utils.hof.uniqueOf = elements => {

	var unique = [ ]

	elements.forEach(element => {

		if (unique.indexOf(element) === -1) {
			unique.push(element)
		}

	})

	return unique

}




utils.array.isIn = (val, array) => {
	return array.indexOf(val) !== -1
}





module.exports = utils
