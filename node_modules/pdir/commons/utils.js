
"use strict"




const fs        = require('fs')
const path      = require('path')
const events    = require('events')
const constants = require('pdir/commons/constants')




const utils = {
	fs:     { },
	hof:    { }
}





const handleFileError = (err, file) => {

	const handledErrors = {
		[constants.errCodes.notFound]: `file ${file} does not exist.`
	}

	process.stderr.write(
		handledErrors.hasOwnProperty(err.code)
			? 'error: ' + handledErrors[err.code] + '\n'
			: 'error: ' + err.message + '\n')

}





utils.fs.listContent = (dir, callback) => {

	fs.lstat(dir, (err, stats) => {

		if (err) {

			handleFileError(err, dir)
			return callback([ ])

		}

		if (!stats.isDirectory( )) {
			process.stderr.write(`error: ${dir} was not a directory.`)
		} else {
			fs.access(dir, fs.R_OK, err => {

				if (err) {

					handleFileError(err, dir)
					return callback([ ])

				}

				fs.readdir(dir, (err, contents) => {
					callback( contents.map(content => {
						return path.resolve(constants.canonicalDir, content)
					}) )
				})

			})
		}

	})

}

utils.fs.emitFileTypes = contents => {

	const emitter = new events.EventEmitter( )

	contents.forEach(content => {
		fs.lstat(content, (err, stats) => {

			if (err) {
				return handleFileError(err, content)
			}

			constants.statTypeMethods.forEach(methodName => {

				if (stats[methodName]( )) {
					emitter.emit(methodName.replace(/^is/, '').toLowerCase( ), content)
				}

			})

		})
	})

	return emitter

}

utils.fs.extension = fpath => {

	const basename = path.basename(fpath)
	const dotIndex = basename.indexOf('.')

	return dotIndex === -1
		? ''
		: basename.slice(dotIndex).replace(/^[.]/, '')

}





utils.hof.uniqueOf = elements => {

	var unique = [ ]

	elements.forEach(element => {

		if (unique.indexOf(element) === -1) {
			unique.push(element)
		}

	})

	return unique

}





module.exports = utils
