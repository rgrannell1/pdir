
"use strict"




const fs        = require('fs')
const path      = require('path')
const events    = require('events')
const crypto    = require('crypto')
const constants = require('pdir/commons/constants')




const utils = {
	fs:     { },
	hof:    { },
	crypto: { }
}





const handleFileError = (err, file) => {

	const handledErrors = {
		[constants.errCodes.notFound]: `file ${file} does not exist.`
	}

	process.stderr.write(
		handledErrors.hasOwnProperty(err.code)
			? 'error: ' + handledErrors[err.code] + '\n'
			: 'error: ' + err.message + '\n')

}





utils.fs.listContent = (dir, callback) => {

	fs.lstat(dir, (err, stats) => {

		if (err) {

			handleFileError(err, dir)
			return callback([ ])

		}

		if (!stats.isDirectory( )) {
			process.stderr.write(`error: ${dir} was not a directory.`)
		} else {

			fs.access(dir, fs.R_OK, err => {

				if (err) {

					handleFileError(err, dir)
					return callback([ ])

				}

				fs.readdir(dir, (err, contents) => {
					callback( contents.map(content => {
						return path.resolve(constants.canonicalDir, dir, content)
					}) )
				})

			})
		}

	})

}

utils.fs.emitFileTypes = contents => {

	const emitter = new events.EventEmitter( )

	contents.forEach(content => {
		fs.lstat(content, (err, stats) => {

			if (err) {
				return handleFileError(err, content)
			}

			constants.statTypeMethods.forEach(methodName => {

				if (stats[methodName]( )) {
					emitter.emit(methodName.replace(/^is/, '').toLowerCase( ), content)
				}

			})

		})
	})

	return emitter

}

utils.fs.extension = fpath => {

	const basename = path.basename(fpath)
	const dotIndex = basename.indexOf('.')

	return dotIndex === -1
		? ''
		: basename.slice(dotIndex).replace(/^[.]/, '')

}

utils.fs.moveFile = (srcPath, tgtPath, callback) => {

	var exited            = false
	const checksumEmitter = new events.EventEmitter( )

	const sourceReadStream  = fs.createReadStream(srcPath)
	const targetWriteStream = fs.createWriteStream(tgtPath)
	const targetReadStream  = fs.createReadStream(tgtPath)

	utils.crypto.checksum(sourceReadStream, (err, readChecksum) => {

		if (err) {
			return done(err)
		}

		checksumEmitter.emit(constants.events.sourceChecksum, readChecksum)

	})

	utils.crypto.checksum(targetReadStream, (err, writeChecksum) => {

		if (err) {
			return done(err)
		}

		checksumEmitter.emit(constants.events.targetChecksum, writeChecksum)

	})

	sourceReadStream.on(constants.events.error, err => {
		done(err)
	})

	targetWriteStream.on(constants.events.error, err => {
		done(err)
	})

	targetWriteStream.on(constants.events.close, ( ) => {
		// get target checksum
		done(null)
	})

	sourceReadStream.pipe(targetWriteStream)


	const checksums = {
		read:  null,
		write: null
	}

	checksumEmitter.on(constants.events.sourceChecksum, readChecksum => {
		checksums.read = readChecksum
	})

	checksumEmitter.on(constants.events.targetChecksum, writeChecksum => {

		checksums.write = writeChecksum

		if (!checksums.read) {
			return process.stderr.write('error: missing read checksum.\n')
		}

		if (checksums.read !== checksums.write) {
			process.stderr.write('error: read and write checksums do not match!\n')
		} else {
			// remove original file.
		}

	})





	const done = err => {

		// callback( )

		if (!exited) {
			// checksum, then delete.
			exited = true
		}

	}

}





utils.hof.uniqueOf = elements => {

	var unique = [ ]

	elements.forEach(element => {

		if (unique.indexOf(element) === -1) {
			unique.push(element)
		}

	})

	return unique

}





utils.crypto.checksum = (readStream, callback) => {

	const exited = false
	const hash   = crypto.createHash(constants.hashes.sha256)

	readStream.on(constants.events.data, data => {
		hash.update(data, 'utf8')
	})

	readStream.on(constants.events.error, err => {
		done(err)
	})

	readStream.on(constants.events.end, ( ) => {
		done(null, hash.digest('hex'))
	})

	const done = (err, digest) => {

		return callback(null, digest)
		exited = true

	}

}





module.exports = utils
